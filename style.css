// Mobile-friendly mic start + adaptive blow detection
document.addEventListener("DOMContentLoaded", function () {
  const onlyCandle = document.getElementById("onlyCandle");
  const startBtn = document.getElementById("startAudio");

  let audioContext, analyser, mic, rafId;
  let baselineRMS = 0;
  let baselineHF = 0;
  let calibrated = false;

  // Compute RMS from time-domain samples
  function computeRMS(uint8) {
    let sumSq = 0;
    for (let i = 0; i < uint8.length; i++) {
      const v = (uint8[i] - 128) / 128; // 0..255 -> -1..1
      sumSq += v * v;
    }
    return Math.sqrt(sumSq / uint8.length) * 100; // scale ~0â€“100
  }

  // Average of higher frequency bins for hiss
  function computeHighFreqAvg(freqData) {
    const start = Math.floor(freqData.length * 0.35);
    const end = Math.floor(freqData.length * 0.9);
    let sum = 0, n = 0;
    for (let i = start; i < end; i++) { sum += freqData[i]; n++; }
    return n ? sum / n : 0;
  }

  function startAnalyser(stream) {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 512;                 // better resolution for phones
    analyser.smoothingTimeConstant = 0.2;   // reduce jitter

    mic = audioContext.createMediaStreamSource(stream);
    mic.connect(analyser);

    calibrate().then(loopDetect);
  }

  async function resumeContextIfNeeded() {
    if (!audioContext) return;
    if (audioContext.state === "suspended") {
      try { await audioContext.resume(); } catch(e){}
    }
  }

  // Calibrate noise floor (~1.2s)
  function calibrate() {
    calibrated = false;
    const rmsBuf = [];
    const hfBuf = [];
    const td = new Uint8Array(analyser.fftSize);
    const fd = new Uint8Array(analyser.frequencyBinCount);

    return new Promise(resolve => {
      const t0 = performance.now();
      function step() {
        analyser.getByteTimeDomainData(td);
        analyser.getByteFrequencyData(fd);
        rmsBuf.push(computeRMS(td));
        hfBuf.push(computeHighFreqAvg(fd));

        if (performance.now() - t0 < 1200) {
          requestAnimationFrame(step);
        } else {
          rmsBuf.sort((a,b)=>a-b); hfBuf.sort((a,b)=>a-b);
          const midR = rmsBuf[Math.floor(rmsBuf.length/2)] || 0;
          const midH = hfBuf[Math.floor(hfBuf.length/2)] || 0;
          baselineRMS = midR;
          baselineHF  = midH;
          calibrated = true;
          resolve();
        }
      }
      step();
    });
  }

  function isBlowing() {
    const td = new Uint8Array(analyser.fftSize);
    const fd = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteTimeDomainData(td);
    analyser.getByteFrequencyData(fd);

    const rms = computeRMS(td);
    const hf  = computeHighFreqAvg(fd);

    // Adaptive thresholds based on baseline
    const rmsThresh = Math.max(baselineRMS + 8, 14);
    const hfThresh  = Math.max(baselineHF  + 10, 18);

    const hissStrong = hf > hfThresh + 8;         // strong high-freq hiss
    const combined   = (rms > rmsThresh) && (hf > hfThresh);

    return hissStrong || combined;
  }

  function loopDetect() {
    cancelAnimationFrame(rafId);
    const tick = () => {
      if (!onlyCandle.classList.contains("out") && calibrated) {
        if (isBlowing()) {
          onlyCandle.classList.add("out"); // hide flame
        }
      }
      rafId = requestAnimationFrame(tick);
    };
    tick();
  }

  async function initMic() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false
        }
      });
      startBtn.classList.add("hidden");
      startAnalyser(stream);
    } catch (err) {
      alert("Mic permission failed. On iPhone/iPad, open in Safari over HTTPS and allow microphone.");
      console.error(err);
    }
  }

  // iOS/Safari: must start on a user gesture
  startBtn.addEventListener("click", async () => {
    await initMic();
    await resumeContextIfNeeded();
  });

  // Also try resuming on any user interaction (safety)
  document.body.addEventListener("touchend", resumeContextIfNeeded, { passive: true });
  document.body.addEventListener("click",    resumeContextIfNeeded);

  // Optional: tap cake to relight (uncomment if you want)
  // document.querySelector(".cake").addEventListener("click", () => {
  //   onlyCandle.classList.remove("out");
  // });
});
